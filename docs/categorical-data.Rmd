---
title: "Basic Data Manupulation in R Part 2"
author: "Matt Herman"
date: "`r Sys.Date()`"
output: rmarkdown::github_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", fig.path = "./output/figures/")
knitr::knit_hooks$set(inline = function(x) {prettyNum(x, big.mark = ",")})
```
## Introduction

Today, we'll go over how some additional data manipulation techniques in R. We'll use functions from the `tidyverse` packages to calculate new variables in a data frame, sort data frames, recode categorical variables, and join multiple data frames. Before we start, a quick review of the functions we talked about last time:

* `filter()`
* `select()`
* `summarize()`
* `tidyverse`

Great! You remember everything. Before we get going, let's do some brief R maintenance. As we talked about last time, there are many packages and functions that we will want to use to do all sorts of interesting things in R. Many of these packages are updated frequently to add new functionality and get rid of bugs.

So we want to make sure we have the latest version of these packages installed on our local machine. The easiest way to do that is to click the "Packages" tab in the lower right hand pane and then click the "Update" button. When the "Update Packages" dialog box pops up, check "Select All" and then click "Update". This may take a few minutes if you have a lot of packages to update. It's good practice to update packages every week or so using this method. 

## (More) Data Manipulation with the `gss_cat` Dataset

We'll pick up [where we left off last time](https://github.com/mfherman/r-study-group/blob/master/docs/basic_data_manip.md) and continue using the GSS dataset that is built into the `forcats` package. The very first thing we're going to do is load the `tidyverse` package. Remember from last session that `tidyverse` is a meta-package that includes a bunch of a good packages (including `forcats()`) for data exploration, manipulation, and analysis. In fact, I usually start all my scripts with `library(tidyverse)`. After we load `tidyverse`, tell R we're going to be using the `gss_cat`data.

```{r load_gss_cat}
library(tidyverse)
data(gss_cat)
```

Do you remember how to examine a data frame? There are a few different ways. If you just want to look at the first 10 rows you can just type the name of the data frame in the console and hit Enter:

```{r view_gss_cat}
gss_cat
```
Alternatively, you can run the `View(gss_cat)` command or click on the name  of the data frame in the Environment pane in the upper right of R Studio.

### Add new variables with `mutate()`

A common task you might need to do is to create a new variable that is in some way related to existing variables in your data set. This might be something relatively simple like changing hours into minutes or changing a continuous variable into a categorical variable. Or it could be a more complex manipulation that relies on several existing variables.

Let's start by creating a new variable (column) that is hours of television watched per year. There is an existing variable, `tvhours`, which is the number of hours per day each respondent reported watching. Mathematically, this is very simple; we'll just multiply the number of hours watched per day by 365 to get the number of hours per year.

```{r mutate_tvhours}
gss_cat_tv <- gss_cat %>%
  mutate(tvhours_year = tvhours * 365)
gss_cat_tv
```

See that new variable at the end of the data frame? That's a lot of hours per year! The `mutate()` function looked at the value of `tvhours` and multiplied by 365, **in each row**. This is the important conceptual difference between `mutate()` and `summarize()`. Remember that we used `summarize()` when we wanted to calculate the mean (for example) for an entire data frame (or vector). In other words, we use `summarize()` when we want to calculate one value for an entire data frame. But we use `mutate()` when we want calculate one value for *each row* in a data frame.

The `mutate()` function has a similar syntax to the the `select()` function we covered last session. The general form of `mutate()` is `mutate(data, new_var = some_calculation)`. And remember, this function will add a new variable with values for each row to the data frame you feed into `mutate()`.

### Add more complex new variables with `mutate()` and `case_when()`

The next example is a more complex use of `mutate()` and also introduces a new function, `case_when()`. Currently, `age` is a continuous numeric variable. But let's say we want to create a new age variable with 3 categories: under 35, 35 to 64, and 65 and over.

```{r mutate_age_cat}
gss_cat_age <- gss_cat_tv %>% 
  mutate(
    age_cat = case_when(
      age < 35 ~ "Young",
      age >=35 & age < 65 ~ "Middle Aged",
      age >= 65 ~ "Old"
      )
    )
gss_cat_age
```

Alright! We added another new variable to the data frame with values in each row. This new variable is called `age_cat` and has three possible values&mdash;`Young`, `Middle Aged`, and `Old`&mdash;that correspond to the age of the respondent.

Let's break down how that worked. First, we get a new value for each row because we used `mutate()`. This new value is in a column called `age_cat`. In the `mutate()` call, we are creating a new variable called `age_cat` and then defining how to create this new variable. In the previous example, this definition was the same calculation for each row `tvhours * 365`. But in this case, we conditionally define the value of a new variable depending on the value of an existing variable. So, we look at the `age` variable and if `age` is less than 35, we want the value of `age_cat` to be `Young`. If `age` is between 35 and 64, then the value of `age_cat` will be `Middle Aged` and if `age` is more than 64, then the value of `age_cat` will be `Old`.

The easiest way to do this is with the `case_when()` function. One way to think about `case_when()` as s a series of if...then statements. For examoke, *if* `age` is `< 35`, *then* `age_cat` is `Young`.

The general syntax of `case_when()` is `case_when(condition ~ result)`. The condition is most often some sort of logical statement that uses one or more Boolean operator (`==`, `!=`, `<`, `>`, etc.) and the result is what you want the value of the new variable to be. So in our exampe above, the first condition, is `age < 35` and the result is `Young`. We then continue for the two other condtions.

Now we're 
### Select columns with `select()`
Now that we've filtered our data frames, maybe we also want to get rid of some variables we don't need for our analysis. This is a job for the `select()` function. It helps us select the columns to keep in our data frame and discards the rest.

```{r select}
gss_small <- select(gss_cat, year, age, race, tvhours)
gss_small
```
You can include as many variables as you want after the `data` argument of `filter()` by separating them with commas. Another nice feature of the `select()` function is the ability to rename columns as you select them. Let's select the same columns as above, but rename tvhours to weekly_tv.

```{r rename}
gss_rename <- select(gss_cat, year, age, race, weekly_tv = tvhours)
gss_rename
```

To generalize, the syntax here is `select(data, new_col_name = old_col_name)`.

### Summary statistics with `summarize()`

We can also calculate summary statistics with the `summarize()` function.

```{r summary_stats}
summarize(gss_cat,
          n = n(),
          age_mean = mean(age, na.rm = TRUE),
          age_med = median(age, na.rm = TRUE),
          tv_mean = mean(tvhours, na.rm = TRUE)
          )
```

The general form of `summarize()` is `summarize(data, new_col_name = summary_function(variable))`. You can include as many summary variables as you want by adding new variables and summary functions after a comma. In the above example, we are creating four summary variables. One important note here is that I included `na.rm = TRUE` in the `mean()` and `median()` function calls. This ensures that any missing or `NA` data is dropped when computing the summary statistics. In this case, I know there is some missing data in these variables. If we hadn't included `na.rm = TRUE`, the result would be `NA` because R does not know how to generate the mean or median from missing data unless we explicitly tell R what to do with the `NA` values.

Next up is a simple, but powerful tool to extend the `summarize()` function: `group_by()`. Using this function we can generate grouped data summaries. Now we will calculate the same summary statistics as above, but instead of for the whole dataset, we will get means and medians segmented by race.

```{r grouped summary}
group_by(gss_cat, race) %>%
  summarize(
    n = n(),
    age_mean = mean(age, na.rm = TRUE),
    age_med = median(age, na.rm = TRUE),
    tv_mean = mean(tvhours, na.rm = TRUE)
  )
```

Cool! In this sample, we see that on average, Black people report watching more hours of TV than white people. Note that this is the exact same code as the last summary, except we added `group_by(gss_cat, race) %>%` before the `summarize()` function. This is saying that before you calculate the mean, group the data frame by the `race` variable and then calculate the mean for each group.

Also, note the use of the `%>%` (pipe). We will talk about this in more detail in another session, but the important thing to know is that the pipe is used to chain functions together. We can think of what the pipe operator does as "and then." So in plain English, what we did above was to group `gss_cat` by `race` and then `summarize` n, mean, and median for each group.

## Let's make a couple charts before we go

One of the most powerful features of R is the many tools available to make beautiful and customizable visualizations. There is so much to learn on this front, but to start, we're just going to make a couple of common and simple charts you could use when exploring a dataset.

We might want to make a histogram to see the age distribution of our sample. That's pretty simple with `ggplot2`, the main package for making static visualizations in R.

```{r age histogram}
ggplot(gss_cat) +
  geom_histogram(aes(age), binwidth = 1)
```

Ok, that's kind of boring. Let's spice it up a little and look at the age distribution, but segmented by race. Maybe the white folks in the GSS sample are older than other races? For this, we'll use a variation on the histogram, the density plot. Don't worry too much about the mathematical details of the plot, just know it represents a smoothed version of a histogram.

```{r age density}
ggplot(gss_cat) +
  geom_density(aes(age, fill = race, color = race), alpha = 0.2)
```

That's more interesting! And pretty colors too! Also, I was right&mdash;the white folks are older!

A different way of visualizing this distribution is with a bar chart where the x-axis is race the y-axis is the number of observations in each race.

```{r race bar plot}
ggplot(gss_cat) +
  geom_bar(aes(race))
```

To add another variable to this chart, let's also look at the distribution of marital status within each race. We'll create a stacked bar chart where each bar segment represents the proportion that has each marital status. I'll also change the colors and add a title, legend, and appropriate scale.

```{r stacked bar plot}
ggplot(gss_cat) +
  geom_bar(aes(race, fill = marital), position = "fill") +
  scale_fill_brewer(palette = "Set2", name = element_blank()) +
  scale_y_continuous(labels = scales::percent) +
  labs(
    x = "Race",
    y = element_blank(),
    title = "Marital Status by Race",
    subtitle = "General Social Survey, 2000 - 2014") +
  theme_bw()
```

There's a lot I threw into that code, but the main point is that `ggplot2` is endlessly customizable. As you add new features and options to a `ggplot` object, you combine the commands with `+`. This acts very much like `%>%` in that it chains multiple lines of code together.

If you want to jump into `ggplot2`, I highly recommend the [visualization chapter from R for Data Science](http://r4ds.had.co.nz/data-visualisation.html).

Ok, that's it for today. More next time on adding new variables, joining data frames, and more!